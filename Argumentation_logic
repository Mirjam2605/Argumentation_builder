import yaml
import ttg
from itertools import chain, combinations, groupby
from operator import itemgetter

# Load your YAML data (replace 'your_yaml_file.yaml' with your actual file)
def load_yaml(file_path):
    with open(file_path, 'r') as file:
        return yaml.safe_load(file)

def powerset(iterable):
    "powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"
    s = list(iterable)
    return chain.from_iterable(combinations(s, r) for r in range(1, len(s)+1))

def state_in_row(state, df):
    for s in state:
        if df.loc[df[s] == True]:
            return True

# Load your YAML data (replace 'your_yaml_file.yaml' with your actual file)
yaml_data = load_yaml('statement_v2.yml')


statements = list(yaml_data.values())
num_state = len(statements)
prop_expr = []
atoms = []

# divide statements into atoms and propositional expressions
for statement in statements:
    if len(statement) != 1 :
        prop_expr.append(statement)
    else:
        atoms.append(statement)

# 1. Find H is consistent: All statements combinations which are true in truth table

#find all statement combinations
statement_combinations = list(powerset(statements))
statement_combinations = [list(ele) for ele in statement_combinations]

# build truth table
truth_table = ttg.Truths(atoms, prop_expr, ints=False).as_pandas #table not right until now!
print("Truth-Table:")
print(truth_table)
print()
#check truth for statement combinations
support_candidates = []
for statements in statement_combinations:
    boolean = truth_table[statements].all(axis=1)
    for b in boolean:
        if b:
            support_candidates.append(statements) 
            break
print("support_candidates:")
print(support_candidates)  
print()

# 2. conclusion entailment

# find h for every H
argument_candidates = []
for support in support_candidates:
    for element in support:
        if ("=>" in element):  #h for implies statements
             # Split the string using the arrow symbol
            supp, h = element.split("=>")
            # Remove leading/trailing spaces
            h = h.strip()
            argument = [support, h]
            argument_candidates.append(argument)
            used = True

#update support candidates by removing used statements for arguments
support_candidates_updated = [entry for entry in support_candidates if "=>" not in "".join(entry)]

#create H,h pair for all basic support candidates without =>
for support in support_candidates_updated:
    for element in support:          
            argument = [support, element]
            argument_candidates.append(argument)
print("argument candidates:")   
print(argument_candidates)
print()

# 3. Find Pairs with H minimal
arguments_final = []

# grouping list based on their conclusion
combined_dict = {}
for sublist in argument_candidates:
    last_arg = sublist[-1]
    other_args = sublist[:-1]

    # Add to the dictionary
    if last_arg not in combined_dict:
        combined_dict[last_arg] = []
    combined_dict[last_arg].extend(other_args)

# take minimal value for conclusion
# Create a new dictionary with the shortest sublist for each key
arguments_final = {key: min(sublists, key=len) for key, sublists in combined_dict.items()}

print("Final arguments:")
print(arguments_final) 


# Put Arguments in dictionary structure

# Build Argumentation Graph

# Claculate properties of arguments